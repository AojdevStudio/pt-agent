"""Tool for calculating optimal workout loads based on user data and readiness."""

from typing import Any, Dict, Optional
from agency_swarm.tools import BaseTool
from pydantic import Field

# Placeholder for database interaction to get 1RM, historical data, etc.
# from personal_ai_trainer.database.models import UserPerformance
# from personal_ai_trainer.database.operations import get_user_1rm

class LoadCalculationTool(BaseTool):
    """
    Calculates optimal training loads (weights) for exercises in a workout plan.
    It considers the user's estimated 1 Rep Max (1RM), historical performance,
    biometric readiness data, and the planned intensity for the week.
    """
    user_id: str = Field(
        ...,
        description="The unique identifier for the user."
    )
    workout_plan: Dict[str, Any] = Field(
        ...,
        description="The structured workout plan for a specific period (e.g., 4 weeks), typically generated by WorkoutGenerationTool. Contains exercises, sets, reps, and intensity modifiers for each week."
    )
    readiness_data: Dict[str, Any] = Field(
        ...,
        description="Biometric readiness information provided by the Biometric Agent. Includes readiness score, contributing factors (sleep, stress), and potentially trends."
    )
    # Optional: Could fetch this within the tool if needed
    historical_performance: Optional[Dict[str, Any]] = Field(
        default=None,
        description="User's historical performance data, including estimated 1RMs for key lifts."
    )

    def _get_estimated_1rm(self, exercise: str) -> Optional[float]:
        """
        Retrieves the estimated 1RM for a given exercise for the user.
        Placeholder: In a real system, this would query a database.
        """
        # Mock 1RMs for common exercises
        mock_1rms = {
            "Bench Press (Barbell/Dumbbell)": 100.0, # Assuming kg or lb consistently
            "Barbell Bench Press": 100.0,
            "Overhead Press (Barbell/Dumbbell)": 60.0,
            "Overhead Press": 60.0,
            "Barbell Squats": 140.0,
            "Squats": 140.0,
            "Deadlifts (Conventional/Sumo - 1x/week)": 180.0,
            "Deadlifts (Heavy)": 180.0,
            "Barbell Rows/Dumbbell Rows": 80.0,
            "Barbell Rows": 80.0,
            # Add more exercises as needed
        }
        # Attempt to find a match, handling variations in naming slightly
        for key, value in mock_1rms.items():
            if exercise.lower().startswith(key.split('(')[0].strip().lower()):
                print(f"Found mock 1RM for {exercise}: {value}")
                return value
        print(f"Warning: No mock 1RM found for exercise '{exercise}'. Cannot calculate load.")
        return None

    def _adjust_intensity_for_readiness(self, base_intensity_modifier: float) -> float:
        """
        Adjusts the planned intensity modifier based on the readiness score.
        Simple linear scaling example.
        """
        readiness_score = self.readiness_data.get("score", 75) # Default to 75 if not provided
        # Scale modifier: e.g., 100 readiness = 1.05x modifier, 50 readiness = 0.95x modifier
        readiness_factor = 1.0 + ((readiness_score - 75) / 50) * 0.1 # Scale around 75
        readiness_factor = max(0.9, min(1.1, readiness_factor)) # Clamp between 0.9 and 1.1

        adjusted_modifier = base_intensity_modifier * readiness_factor
        print(f"Readiness score: {readiness_score}, Factor: {readiness_factor:.2f}, Base Mod: {base_intensity_modifier:.2f}, Adjusted Mod: {adjusted_modifier:.2f}")
        return adjusted_modifier

    def _calculate_working_weight(self, estimated_1rm: float, adjusted_intensity_modifier: float) -> float:
        """
        Calculates the target working weight based on 1RM and the adjusted intensity.
        This assumes the intensity modifier directly maps to a percentage of 1RM.
        """
        # This is a simplification. Real calculations might involve specific %1RM tables for rep ranges.
        target_weight = estimated_1rm * adjusted_intensity_modifier
        # Round to nearest sensible weight increment (e.g., 2.5 kg/lb)
        increment = 2.5
        rounded_weight = round(target_weight / increment) * increment
        print(f"Calculated Target Weight: {target_weight:.2f}, Rounded: {rounded_weight}")
        return rounded_weight

    def run(self) -> Dict[str, Any]:
        """
        Executes the load calculation logic for the entire workout plan.

        Returns:
            Dict[str, Any]: The workout plan dictionary updated with calculated loads
                            for each exercise where possible.
        """
        print(f"Calculating loads for user {self.user_id} with readiness: {self.readiness_data.get('score', 'N/A')}")

        updated_plan = self.workout_plan.copy() # Avoid modifying the input dict directly

        for week_key, weekly_plan in updated_plan.items():
            if not isinstance(weekly_plan, dict): continue # Skip if week data isn't a dict

            for day_type, exercises in weekly_plan.items():
                if not isinstance(exercises, list): continue # Skip if exercises aren't a list

                for exercise_details in exercises:
                    if not isinstance(exercise_details, dict): continue # Skip if exercise isn't a dict

                    exercise_name = exercise_details.get("exercise")
                    base_intensity_mod = exercise_details.get("intensity_modifier", 1.0)

                    if not exercise_name:
                        print(f"Warning: Skipping exercise with missing name in {week_key}/{day_type}")
                        continue

                    estimated_1rm = self._get_estimated_1rm(exercise_name)
                    if estimated_1rm is None:
                        exercise_details["calculated_load"] = "1RM N/A"
                        continue

                    # Adjust intensity based on readiness
                    readiness_adjusted_modifier = self._adjust_intensity_for_readiness(base_intensity_mod)

                    # Calculate the final working weight
                    working_weight = self._calculate_working_weight(estimated_1rm, readiness_adjusted_modifier)

                    exercise_details["calculated_load"] = f"{working_weight} kg/lb" # Add units clarification
                    exercise_details["debug_1rm"] = estimated_1rm # Add for debugging/transparency
                    exercise_details["debug_readiness_mod"] = readiness_adjusted_modifier

        print("Finished calculating loads.")
        return updated_plan

# Example Usage (for testing purposes)
if __name__ == "__main__":
    # Example plan structure from WorkoutGenerationTool output
    test_plan = {
        "week_1": {
            "push": [
                {"exercise": "Barbell Bench Press", "sets": 3, "reps": "8-12", "intensity_modifier": 0.95, "calculated_load": None},
                {"exercise": "Overhead Press", "sets": 3, "reps": "8-12", "intensity_modifier": 0.95, "calculated_load": None}
            ],
            "pull": [
                {"exercise": "Barbell Rows", "sets": 3, "reps": "8-12", "intensity_modifier": 0.95, "calculated_load": None}
            ],
            "legs": [
                {"exercise": "Barbell Squats", "sets": 3, "reps": "8-12", "intensity_modifier": 0.95, "calculated_load": None},
                {"exercise": "Unknown Exercise", "sets": 3, "reps": "8-12", "intensity_modifier": 0.95, "calculated_load": None}
            ]
        }
        # ... potentially more weeks
    }
    test_readiness = {"score": 90, "factors": ["Good sleep"]}

    tool = LoadCalculationTool(
        user_id="test_user_123",
        workout_plan=test_plan,
        readiness_data=test_readiness
    )
    updated_plan_result = tool.run()
    import json
    print("\nUpdated Plan with Calculated Loads:")
    print(json.dumps(updated_plan_result, indent=2))

    # Test with lower readiness
    test_readiness_low = {"score": 60, "factors": ["Poor sleep"]}
    tool_low_readiness = LoadCalculationTool(
        user_id="test_user_123",
        workout_plan=test_plan, # Use the original plan structure again
        readiness_data=test_readiness_low
    )
    updated_plan_low_readiness = tool_low_readiness.run()
    print("\nUpdated Plan (Low Readiness):")
    print(json.dumps(updated_plan_low_readiness, indent=2))